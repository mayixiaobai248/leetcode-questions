# 7.25第一遍
在代码随想录的帮助下完成，一共是有两种解法：

**贪心解法**：
贪心算法是这样的，就是如果前面求出来是负数的话，那么需要重新开始

其关键在于：**不能让“连续和”为负数的时候加上下一个元素，而不是 不让“连续和”加上一个负数**

>+ 局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。
>+ 全局最优：选取最大“连续和”
>+ 局部最优的情况下，并记录最大的“连续和”，可以推出全局最优。

**动态规划解法**：
动态规划解法很简单，下面我将分成五步走：
>+ dp[i]表示[0, i]范围内的最长序列和
>+ 对于dp[i]，一共是有两种求法，要不然就是dp[i-1]+nums[i]，要不然就是nums[i]，两者取最大即可
>+ 那么我们初始化，初始化dp[0]即可，dp[0]=nums[0]
>+ 后一个状态依赖于前一个状态，所以从前往后遍历